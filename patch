diff --git a/uttlv/__init__.py b/uttlv/__init__.py
index 484ea17..39972f8 100644
--- a/uttlv/__init__.py
+++ b/uttlv/__init__.py
@@ -1,4 +1,4 @@
-from .encoder import DefaultEncoder, IntEncoder, BytesEncoder, AsciiEncoder, Utf8Encoder, Utf16Encoder, Utf32Encoder
+from .encoder import DefaultEncoder, IntEncoder, StructEncoder, BytesEncoder, AsciiEncoder, Utf8Encoder, Utf16Encoder, Utf32Encoder
 from .tlv import TLV, EmptyTLV
 
 # Package version
diff --git a/uttlv/encoder.py b/uttlv/encoder.py
index 62d9f3b..e79eaec 100644
--- a/uttlv/encoder.py
+++ b/uttlv/encoder.py
@@ -1,8 +1,10 @@
 from __future__ import annotations
 from binascii import hexlify
-
+import struct
 
 class DefaultEncoder(object):
+    def __init__(self, tmpl=None):
+        self.tmpl = tmpl
 
     def default(self, obj):
         try:
@@ -36,6 +38,21 @@ class IntEncoder(DefaultEncoder):
     def parse(self, obj, _cls):
         return int.from_bytes(obj, byteorder='big')
 
+class StructEncoder(DefaultEncoder):
+
+    def default(self, obj): # TODO implement
+        if isinstance(obj, int):
+            return obj.to_bytes(4, byteorder='big')
+        return super().default(obj)
+
+    def to_string(self, obj, offset=0, use_names=False):
+        return str(hexlify(obj), 'ascii')
+
+    def parse(self, obj, _cls):
+        tmpl = self.tmpl
+        tlen = struct.calcsize(tmpl)
+        return struct.unpack(tmpl, obj)[0]
+
 
 class AsciiEncoder(DefaultEncoder):
 
diff --git a/uttlv/tlv.py b/uttlv/tlv.py
index d81e06a..d3ae8aa 100644
--- a/uttlv/tlv.py
+++ b/uttlv/tlv.py
@@ -25,10 +25,10 @@ class TLV:
             class name is the name of the class that represents the type 
                 of the value.
     '''
-    Config = enum.Enum('Config', 'Type Name')
+    Config = enum.Enum('Config', 'Type Name Tmpl')
     _global_tag_map = {}
 
-    def __init__(self, indent=4, tag_size=1, len_size=None, endian='big'):
+    def __init__(self, indent=4, tag_size=1, len_size=None, endian='big', tv=False):
         '''
         :args:
             indent: How many spaces to use in tree() method
@@ -42,6 +42,7 @@ class TLV:
         self.tag_size = tag_size
         self.len_size = len_size
         self.endian = endian
+        self.tv = tv
         self._items = {}
         self._local_tag_map = None
 
@@ -92,7 +93,7 @@ class TLV:
 
     def _new_equivalent_tlv(self) -> TLV:
         '''Creates a new TLV object with the same decode settings as self. Useful for parsing nested structures.'''
-        return TLV(self.indent, self.tag_size, self.len_size, self.endian)
+        return TLV(self.indent, self.tag_size, self.len_size, self.endian, self.tv)
 
     @classmethod
     def set_tag_map(cls, map: Dict) -> None:
@@ -226,18 +227,30 @@ class TLV:
         while len(aux) > min_size:
             # Tag value
             t = int.from_bytes(aux[:self.tag_size], byteorder=self.endian)
-            # Len value
+            # Strip tag value, length (if any) and value remain
             aux = aux[self.tag_size:]
+            tg_cfg = self.tag_map.get(t)
+            len_size = 0
+            l = 0
+            tmpl = None
+            if self.tv:
+                if tg_cfg is not None:
+                    tmpl = tg_cfg.get(TLV.Config.Tmpl)
+                    if tmpl is not None:
+                        l = struct.calcsize(tmpl)
+                    else:
+                        raise AttributeError(f'Missing template to decode attribute {hexlify(t)}')
+                else:
+                    raise AttributeError(f'Unknown attribute {t} in TV decoding')
+            else:
+                # Len value
                 len_size = self.len_size or self.decode_len_size(aux)
                 offset = 0 if len_size == 1 else 1
                 l = int.from_bytes(aux[offset:len_size], byteorder=self.endian)
             # Value
             aux = aux[len_size:]
             v = aux[:l]
-            # Next value
-            aux = aux[l:]
             # Check if tag has any parser
-            tg_cfg = self.tag_map.get(t)
             if tg_cfg is not None:
                 tg_type = tg_cfg.get(TLV.Config.Type)
                 if tg_type is not None:
@@ -248,9 +261,11 @@ class TLV:
                     else:
                         frm = ALLOWED_TYPES.get(tg_type)
                         if frm is not None:
-                            v = frm().parse(v, self._new_equivalent_tlv())
+                            v = frm(tmpl = tg_cfg.get(TLV.Config.Tmpl)).parse(v, self._new_equivalent_tlv())
             # Set value
             self.__setitem__(t, v)
+            # Next value
+            aux = aux[l:]
         # Done parsing
         return True
 
@@ -297,6 +312,7 @@ class TLVIterator:
 ALLOWED_TYPES = {
     TLV: DefaultEncoder,
     int: IntEncoder,
+    struct: StructEncoder,
     bytes: BytesEncoder,
     str: Utf8Encoder,
 }
